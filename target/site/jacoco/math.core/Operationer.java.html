<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="es"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Operationer.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">BeyondDouble</a> &gt; <a href="index.source.html" class="el_package">math.core</a> &gt; <span class="el_source">Operationer.java</span></div><h1>Operationer.java</h1><pre class="source lang-java linenums">package math.core;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import java.util.ArrayList;

/**

	Manages the operations and results of the four basic mathemathic operations. 
	Intended to be only used as a stakeholder manager for its functions.&lt;br&gt;&lt;br&gt;

	Provides core arithmetic operations for arbitrary-precision integer arithmetic using string-based number representation.
	This class implements fundamental mathematical operations (addition, subtraction, multiplication, division) with
	support for precision control, comparison utilities, and zero-padding/trimming operations.

	&lt;p&gt;&lt;b&gt;Key Features:&lt;/b&gt;&lt;/p&gt;
	&lt;ul&gt;

		&lt;li&gt;&lt;b&gt;Arbitrary-Precision Arithmetic&lt;/b&gt; - Handles string-based integer numbers of any size limited only by memory&lt;/li&gt;
		&lt;li&gt;&lt;b&gt;Full Operation Suite&lt;/b&gt; - Addition, subtraction, multiplication, and division with configurable precision&lt;/li&gt;
		&lt;li&gt;&lt;b&gt;Comparison Utilities&lt;/b&gt; - Specialized methods for comparing integer and decimal components&lt;/li&gt;
		&lt;li&gt;&lt;b&gt;Zero Management&lt;/b&gt; - Padding (left/right) and trimming (left/right) operations for number normalization&lt;/li&gt;
		&lt;li&gt;&lt;b&gt;Asynchronous Processing&lt;/b&gt; - Parallel computation for large-number operations&lt;/li&gt;
		&lt;li&gt;&lt;b&gt;Increment/Decrement Operations&lt;/b&gt; - Efficient string-based number modification&lt;/li&gt;
		&lt;li&gt;&lt;b&gt;Division Utilities&lt;/b&gt; - Quotient/remainder calculation and decimal expansion with precision control&lt;/li&gt;

	&lt;/ul&gt;

	&lt;p&gt;&lt;b&gt;Usage Example:&lt;/b&gt;&lt;/p&gt;
	&lt;pre&gt;{@code

		public class MyClass{

			private Operationer operationManager = new Operationer();

		}

	}&lt;/pre&gt;

	@author Dandelion
	@version v0.0.4
	@since v0.0.9

*/

public class Operationer{

	/**

		Empty constructor.

	*/

<span class="fc" id="L57">	public Operationer(){}</span>

	/**

		Compares two positive integer numbers as two {@code String}.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			int result = this.operationManager.compareIntegerParts(&quot;45&quot;, &quot;50&quot;);

		}&lt;/pre&gt;

		The return value will be {@code result = -1}

		@param a Integer number as a {@code String}
		@param b Integer number as a {@code String}

		@return int Returns an x value ranging from {@literal -1&lt;x&lt;1} where x belongs to integers. Where {@literal 0} if both are 
		equal, {@literal 1} if {@literal n&gt;m} and {@literal -1} if {@literal n&lt;m}.
		@since v0.0.1

	*/

	protected int compareIntegerParts(String a, String b){

<span class="fc" id="L83">		int aLength = a.length();</span>
<span class="fc" id="L84">		int bLength = b.length();</span>

		//Case 1: Diferent length
<span class="fc bfc" id="L87" title="All 4 branches covered.">		if (aLength!=bLength) return aLength&gt;bLength ? 1 : -1;</span>

		//Case 2: Same length

<span class="fc bfc" id="L91" title="All 2 branches covered.">		for (int i=0; i&lt;aLength; i++){</span>

<span class="fc" id="L93">			char c1 = a.charAt(i);</span>
<span class="fc" id="L94">			char c2 = b.charAt(i);</span>

<span class="fc bfc" id="L96" title="All 4 branches covered.">			if (c1!=c2) return c1&gt;c2 ? 1 : -1;</span>

		}

<span class="fc" id="L100">		return 0;</span>

	}

	/**

		Compares two decimal parts as two positive integer numbers as two {@code String}.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			int result = this.operationManager.compareDecimalParts(&quot;5&quot;, &quot;52&quot;);

		}&lt;/pre&gt;

		The return value will be {@code result = 1}

		@param a Integer number as a {@code String}
		@param b Integer number as a {@code String}

		@return int Returns an x value ranging from {@literal -1&lt;x&lt;1} where x belongs to integers. Where {@literal 0} if both are 
		equal, {@literal 1} if {@literal n&lt;m} and {@literal -1} if {@literal n&gt;m}.
		@since v0.0.1

	*/

	protected int compareDecimalParts(String a, String b){

<span class="fc" id="L128">		int aLength = a.length();</span>
<span class="fc" id="L129">		int bLength = b.length();</span>

<span class="fc bfc" id="L131" title="All 2 branches covered.">		int minLength = aLength&lt;bLength ? aLength : bLength;</span>

<span class="fc bfc" id="L133" title="All 2 branches covered.">		for (int i=0; i&lt;minLength; i++){</span>

<span class="fc" id="L135">			char c1 = a.charAt(i);</span>
<span class="fc" id="L136">			char c2 = b.charAt(i);</span>

<span class="fc bfc" id="L138" title="All 4 branches covered.">			if (c1!=c2) return c1&gt;c2 ? 1 : -1;</span>

		}

<span class="fc bfc" id="L142" title="All 2 branches covered.">		if (aLength==bLength) return 0;</span>

<span class="fc bfc" id="L144" title="All 2 branches covered.">		return aLength&gt;bLength ? 1 : -1;</span>

	}

	/**

		Add zeros to the {@code String} result to the right until the length matches the length parameter.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String result = this.operationManager.padZerosRight(&quot;5&quot;, 3);

		}&lt;/pre&gt;

		The return value will be {@code result = &quot;500&quot;}

		@param str Integer number as a {@code String}
		@param length Intented length for the {@code String} result.

		@return String Returns String that matches the length parameter.
		@since v0.0.1

	*/

	protected String padZerosRight(String str, int length){

<span class="fc" id="L171">		int strLength = str.length();</span>

<span class="fc bfc" id="L173" title="All 2 branches covered.">		if (strLength&gt;=length){</span>

<span class="fc" id="L175">			return str;</span>

		}

<span class="fc" id="L179">		return new StringBuilder(str).append(&quot;0&quot;.repeat(length-strLength)).toString();</span>

	}

	/**

		Add zeros to the {@code String} result to the left until the length matches the length parameter.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String result = this.operationManager.padZerosLeft(&quot;5&quot;, 3);

		}&lt;/pre&gt;

		The return value will be {@code result = &quot;005&quot;}

		@param str Integer number as a {@code String}
		@param length Intented length for the {@code String} result.

		@return String Returns String that matches the length parameter.
		@since v0.0.1

	*/

	protected String padZerosLeft(String str, int length){

<span class="fc" id="L206">		int strLength = str.length();</span>

<span class="fc bfc" id="L208" title="All 2 branches covered.">		if (strLength&gt;=length){</span>

<span class="fc" id="L210">			return str;</span>

		}

<span class="fc" id="L214">		return new StringBuilder(str).insert(0, &quot;0&quot;.repeat(length-strLength)).toString();</span>

	}

	/**

		Trims right zeros.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String result = this.operationManager.trimZerosRight(&quot;500&quot;);

		}&lt;/pre&gt;

		The return value will be {@code result = &quot;5&quot;}

		@param str String value.

		@return String Returns the trim string.
		@since v0.0.2

	*/

	protected String trimZerosRight(String str){

<span class="fc" id="L240">		return str.replaceAll(&quot;[0]+$&quot;, &quot;&quot;);</span>

	}

	/**

		Trims left zeros.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String result = this.operationManager.trimZerosRight(&quot;000&quot;);

		}&lt;/pre&gt;

		The return value will be {@code result = &quot;0&quot;}

		@param str String value.

		@return String Returns the trim string.
		@since v0.0.2

	*/

	protected String trimZerosLeft(String str){

<span class="fc" id="L266">		return str.replaceAll(&quot;^[0]+(?!$)&quot;, &quot;&quot;);</span>

	}

	/**

		Trims left zeros.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String result = this.operationManager.trimAllZerosLeft(&quot;000&quot;);

		}&lt;/pre&gt;

		The return value will be {@code result = empty}

		@param str String value.

		@return String Returns the trim string.
		@since v0.0.3

	*/

	protected String trimAllZerosLeft(String str){

<span class="fc" id="L292">		return str.replaceAll(&quot;^[0]+&quot;, &quot;&quot;);</span>

	}

	/**

		Adds integers as {@code String} logicly and sequentially.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String result = this.operationManager.asyncAddition(new String[] {

				&quot;1&quot;, &quot;2&quot;, &quot;3&quot;

			});

		}&lt;/pre&gt;

		The return value will be {@code result = &quot;7&quot;}

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Note:&lt;/b&gt; &lt;ol&gt;&lt;li&gt;The return value will have the same String length as the max String length value from the array.&lt;/li&gt;&lt;/ol&gt;

		@param integers {@code String} array made out of positive integer numbers.

		@return String Result from the addition of the integers.
		@see math.core.Operationer#addTwoTogether(String, String, boolean)
		@since v0.0.3

	*/

	protected String asyncAddition(String[] integers) {

<span class="fc" id="L325">		int arrayLength = integers.length;</span>

<span class="fc bfc" id="L327" title="All 2 branches covered.">		if (arrayLength==1){</span>

<span class="fc" id="L329">			return integers[0];</span>

<span class="fc bfc" id="L331" title="All 2 branches covered.">		}else if (arrayLength==2){</span>

<span class="fc" id="L333">			return this.addTwoTogether(integers[0], integers[1], true);</span>

<span class="fc bfc" id="L335" title="All 2 branches covered.">		}else if (arrayLength==3){</span>

<span class="fc" id="L337">			return this.addTwoTogether(this.addTwoTogether(</span>

				integers[0],
				integers[1],
				true

			), integers[2], true);

		}else{

<span class="fc" id="L347">			return asyncAdditionRecursive(integers).join();</span>

		}

	}

	/**

		Adds two integers as {@code String} logicly and sequentially.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String result = this.operationManager.addTwoTogether(&quot;5&quot;, &quot;2&quot;, true);

		}&lt;/pre&gt;

		The return value will be {@code result = &quot;7&quot;}

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Notes:&lt;/b&gt;
		&lt;ol&gt;

			&lt;li&gt;The {@code String} length relation between the parameters must satisfy thisInteger &gt;= otherInteger.&lt;/li&gt;
			&lt;li&gt;For subtraction, the relation between the integer parameters must satisfy thisInteger &gt;= otherInteger.&lt;/li&gt;
			&lt;li&gt;The return value will have the same String length as the {@code String} thisInteger length.&lt;/li&gt;

		&lt;/ol&gt;

		@param thisInteger Positive integer number as {@code String}.
		@param otherInteger Positive integer number as {@code String}.
		@param isAddition Is addition or substraction as {@code boolean}.

		@return String Result from the addition of the integers.
		@see math.core.Operationer#padZerosLeft(String, int)
		@since v0.0.3

	*/

	protected String addTwoTogether(String thisInteger, String otherInteger, boolean isAddition){

<span class="fc" id="L387">		int maxLength = thisInteger.length();</span>
<span class="fc" id="L388">		int minLength = otherInteger.length();</span>

<span class="fc" id="L390">		String thisFullNumber = thisInteger;</span>
<span class="fc" id="L391">		String otherFullNumber = padZerosLeft(otherInteger, maxLength);</span>

<span class="fc" id="L393">		StringBuilder result = this.addTwoTogether(new StringBuilder(), thisFullNumber, otherFullNumber, 0, 0, maxLength - 1, otherFullNumber.length() - minLength - 1, isAddition);</span>

<span class="fc" id="L395">		return result.toString();</span>

	}

	/**

		Increases the integer's value stored as a {@code String} by one.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String result = this.operationManager.increase(&quot;0&quot;);

		}&lt;/pre&gt;

		The return value will be {@code result = &quot;1&quot;}

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Notes:&lt;/b&gt;
		&lt;ol&gt;

			&lt;li&gt;The return value will have the same String length as the parameter's length.&lt;/li&gt;
			&lt;li&gt;The parameter must satisfy thisInteger &gt;= 0.&lt;/li&gt;

		&lt;/ol&gt;

		@param thisInteger Positive integer number as {@code String}.
		@return String Parameter increased by one.
		@since v0.0.3

	*/

	protected String increase(String thisInteger){

<span class="fc" id="L428">		int length = thisInteger.length() - 1;</span>

<span class="fc" id="L430">		String paddedOne = &quot;0&quot;.repeat(length) + &quot;1&quot;;</span>

<span class="fc" id="L432">		StringBuilder result = this.addTwoTogether(new StringBuilder(), thisInteger, paddedOne, 0, 0, length, length - 1, true);</span>

<span class="fc" id="L434">		return result.toString();</span>

	}

	/**

		Decreases the integer's value stored as a {@code String} by one.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String result = this.operationManager.decrease(&quot;1&quot;);

		}&lt;/pre&gt;

		The return value will be {@code result = &quot;0&quot;}

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Notes:&lt;/b&gt;
		&lt;ol&gt;

			&lt;li&gt;The return value will have the same String length as the parameter's length.&lt;/li&gt;
			&lt;li&gt;The parameter must satisfy thisInteger &gt;= 1.&lt;/li&gt;

		&lt;/ol&gt;

		@param thisInteger Positive integer number as {@code String}.
		@return String Parameter decreased by one.
		@since v0.0.3

	*/

	protected String decrease(String thisInteger){

<span class="fc" id="L467">		int length = thisInteger.length() - 1;</span>

<span class="fc" id="L469">		String paddedOne = &quot;0&quot;.repeat(length) + &quot;1&quot;;</span>

<span class="fc" id="L471">		StringBuilder result = this.addTwoTogether(new StringBuilder(), thisInteger, paddedOne, 0, 0, length, length - 1, false);</span>

<span class="fc" id="L473">		return this.trimZerosLeft(result.toString());</span>

	}

	/**

		Multiplies integers as {@code String} logicly and sequentially.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String result = this.operationManager.multiplication(&quot;12&quot;, &quot;3&quot;);

		}&lt;/pre&gt;

		The return value will be {@code result = &quot;36&quot;}

		@param thisInteger First positive integer as {@code String}.
		@param otherInteger Second positive integer as {@code String}.

		@return String Result from the multiplication of the integers.
		@see math.core.Operationer#asyncAddition(String[])
		@since v0.0.1

	*/

	protected String multiplication(String thisInteger, String otherInteger) {

<span class="fc" id="L501">		int arrayLength = otherInteger.length();</span>

<span class="fc" id="L503">		String[] integerRows = this.multiplication(new String[arrayLength], new StringBuilder(), thisInteger, otherInteger, arrayLength - 1);</span>

<span class="fc" id="L505">		return this.asyncAddition(integerRows);</span>

	}

	/**

		Divides integers as {@code String} logicly and sequentially.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String[] result = this.operationManager.division(&quot;7&quot;, &quot;5&quot;, 20);

		}&lt;/pre&gt;

		The return values will be {@code result[0] = &quot;1&quot;} and {@code result[1] = &quot;4&quot;}

		@param dividend Positive integer dividend as {@code String}.
		@param divisor Positive integer divisor as {@code String}.
		@param precision Decimal precision as {@code long}.

		@return String[] Two length array which conatains the result from the division of the 
		integers, index {@code 0} contains the integer part and index {@code 1} the decimal part.

		@see math.core.Operationer#compareIntegerParts(String, String)
		@see math.core.Operationer#quotient(String, String)
		@see math.core.Operationer#calculateDecimalPartForDivision(String, String, long)

		@since v0.0.1

	*/

	protected String[] division(String dividend, String divisor, long precision) {

<span class="fc bfc" id="L539" title="All 2 branches covered.">		if (dividend.matches(&quot;0&quot;)) return new String[] {&quot;0&quot;, &quot;&quot;};</span>

<span class="fc" id="L541">		int isGreaterThanDividend = this.compareIntegerParts(dividend, divisor);</span>

<span class="fc bfc" id="L543" title="All 2 branches covered.">		if (isGreaterThanDividend&gt;=0){</span>

<span class="fc" id="L545">			String[] quotient = this.quotient(dividend, divisor);</span>

<span class="fc bfc" id="L547" title="All 2 branches covered.">			if (quotient[1].isEmpty()){</span>

<span class="fc" id="L549">				return new String[] {quotient[0], &quot;&quot;};</span>

			}else{

<span class="fc" id="L553">				return new String[] {quotient[0], this.calculateDecimalPartForDivision(quotient[1]+&quot;0&quot;, divisor, precision)};</span>

			}

		}else{

<span class="fc" id="L559">			return new String[] {&quot;0&quot;, this.calculateDecimalPartForDivision(dividend+&quot;0&quot;, divisor, precision)};</span>

		}

	}

	/**

		Divides integers as {@code String} logicly and sequentially.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String[] result = this.operationManager.quotient(&quot;7&quot;, &quot;5&quot;);

		}&lt;/pre&gt;

		The return values will be {@code result[0] = &quot;1&quot;} and {@code result[1] = &quot;2&quot;}

		@param dividend Positive integer dividend as {@code String}.
		@param divisor Positive integer divisor as {@code String}.

		@return String[] Two length array which conatains the result from the division of the 
		integers, index {@code 0} contains the quotient and index {@code 1} the decimal remainder.

		@see math.core.Operationer#compareIntegerParts(String, String)
		@see math.core.Operationer#multiplication(String, String)
		@see math.core.Operationer#addTwoTogether(String, String, boolean)
		@see math.core.Operationer#trimZerosLeft(String)

		@since v0.0.4

	*/

	protected String[] quotient(String dividend, String divisor) {

<span class="fc" id="L595">		int index = 3 * (dividend.length() - divisor.length());</span>

<span class="fc" id="L597">		ArrayList&lt;String&gt; powers = this.powersOfTwo(index);</span>
<span class="fc" id="L598">		String factor = powers.get(powers.size() - 1);</span>

<span class="fc bfc" id="L600" title="All 2 branches covered.">		while(this.compareIntegerParts(this.multiplication(factor, divisor), dividend)&lt;0){</span>

<span class="fc" id="L602">			factor = this.addTwoTogether(factor, factor, true);</span>

<span class="fc" id="L604">			powers.add(factor);</span>

		}

<span class="fc" id="L608">		index = powers.size() - 1;</span>

<span class="fc" id="L610">		String product = this.multiplication(factor, divisor);</span>
<span class="fc" id="L611">		int isGreaterThanProduct = this.compareIntegerParts(product, dividend);</span>
<span class="fc" id="L612">		boolean lastLower = false;</span>

<span class="fc" id="L614">		String lastFactor = &quot;&quot;, lastProduct = &quot;&quot;;</span>

		do{

<span class="fc" id="L618">			index--;</span>

<span class="fc bfc" id="L620" title="All 2 branches covered.">			if (isGreaterThanProduct!=0){</span>

<span class="fc bfc" id="L622" title="All 2 branches covered.">				lastLower = isGreaterThanProduct&lt;0;</span>

<span class="fc bfc" id="L624" title="All 2 branches covered.">				if (lastLower){</span>

<span class="fc" id="L626">					lastFactor = factor;</span>
<span class="fc" id="L627">					lastProduct = product;</span>

				}

<span class="fc" id="L631">				factor = this.trimZerosLeft(this.addTwoTogether(factor, powers.get(index), lastLower));</span>

			}else{

<span class="fc" id="L635">				return new String[] {factor, &quot;&quot;};</span>

			}

<span class="fc" id="L639">			product = this.multiplication(factor, divisor);</span>
<span class="fc" id="L640">			isGreaterThanProduct = this.compareIntegerParts(product, dividend);</span>

<span class="fc bfc" id="L642" title="All 2 branches covered.">		}while(index&gt;0);</span>

<span class="fc bfc" id="L644" title="All 2 branches covered.">		if (isGreaterThanProduct&gt;0){</span>

<span class="fc" id="L646">			factor = lastFactor;</span>
<span class="fc" id="L647">			product = lastProduct;</span>

		}

<span class="fc" id="L651">		return new String[] {factor, this.trimAllZerosLeft(this.addTwoTogether(dividend, product, false))};</span>

	}

	/**

		Calculates the decimal part of a division using the remainder and divisor as {@code String} logicly and sequentially.

		&lt;br&gt;&lt;br&gt;&lt;b&gt;Usage Example&lt;/b&gt;
		&lt;pre&gt;{@code

			String result = this.operationManager.calculateDecimalPartForDivision(&quot;20&quot;, &quot;5&quot;, 20);

		}&lt;/pre&gt;

		The return value will be {@code result = &quot;4&quot;}

		@param remainder Integer remainder as {@code String}.
		@param divisor Integer Divisor as {@code String}.
		@param precision Decimal precision as {@code long}.

		@return String Decimal part for the division.

		@see math.core.Operationer#compareIntegerParts(String, String)
		@see math.core.Operationer#addTwoTogether(String, String, boolean)
		@see math.core.Operationer#increase(String)

		@since v0.0.1

	*/

	private String calculateDecimalPartForDivision(String remainder, String divisor, long precision){

<span class="fc" id="L684">		StringBuilder result = new StringBuilder(&quot;&quot;);</span>

<span class="fc bfc" id="L686" title="All 2 branches covered.">		for (long i=0; i&lt;precision; i++){</span>

<span class="fc" id="L688">			int isGreaterThanDividend = this.compareIntegerParts(remainder, divisor);</span>

<span class="fc" id="L690">			byte counter = 0;</span>

<span class="fc bfc" id="L692" title="All 2 branches covered.">			while(isGreaterThanDividend&gt;=0){</span>

<span class="fc" id="L694">				remainder = this.trimZerosLeft(this.addTwoTogether(remainder.toString(), divisor.toString(), false));</span>

<span class="fc" id="L696">				counter++;</span>

<span class="fc" id="L698">				isGreaterThanDividend = this.compareIntegerParts(remainder, divisor);</span>

			}

<span class="fc bfc" id="L702" title="All 2 branches covered.">			if (!remainder.matches(&quot;0&quot;)){</span>

<span class="fc" id="L704">				result.append(counter);</span>
<span class="fc" id="L705">				remainder+= &quot;0&quot;;</span>

			}else{

<span class="pc bpc" id="L709" title="1 of 2 branches missed.">				if (counter&lt;10){</span>

<span class="fc" id="L711">					result.append(counter);</span>

<span class="fc" id="L713">					return result.toString();</span>

				}else{

<span class="nc" id="L717">					return this.increase(result.toString());</span>

				}

			}

		}

<span class="fc" id="L725">		return result.toString();</span>

	}

	@SuppressWarnings(&quot;unchecked&quot;) private CompletableFuture&lt;String&gt; asyncAdditionRecursive(String[] integers) {

<span class="fc bfc" id="L731" title="All 2 branches covered.">		if (integers.length==1){</span>

<span class="fc" id="L733">			return CompletableFuture.completedFuture(integers[0]);</span>

		}

<span class="fc" id="L737">		int pairs = integers.length / 2;</span>

<span class="fc" id="L739">		CompletableFuture&lt;String&gt;[] futures = new CompletableFuture[pairs];</span>
<span class="fc" id="L740">		ExecutorService executor = Executors.newFixedThreadPool(pairs);</span>

<span class="fc bfc" id="L742" title="All 2 branches covered.">		for (int i=0; i&lt;pairs; i++){</span>

<span class="fc" id="L744">			int index = i * 2;</span>

<span class="fc" id="L746">			futures[i] = CompletableFuture.supplyAsync(() -&gt; this.addTwoTogether(integers[index], integers[index + 1], true), executor);</span>

		}

<span class="fc" id="L750">		return CompletableFuture.allOf(futures).thenCompose(v -&gt; {</span>

<span class="fc" id="L752">			String[] results = new String[pairs + (integers.length % 2)];</span>

<span class="fc bfc" id="L754" title="All 2 branches covered.">			for (int i=0; i&lt;pairs; i++){</span>

<span class="fc" id="L756">				results[i] = futures[i].join();</span>

			}

<span class="fc bfc" id="L760" title="All 2 branches covered.">			if (integers.length%2!=0){</span>

<span class="fc" id="L762">				results[pairs] = integers[integers.length - 1];</span>

			}

<span class="fc" id="L766">			executor.shutdown();</span>

<span class="fc" id="L768">			return asyncAdditionRecursive(results);</span>

		});
	}

	private StringBuilder addTwoTogether(StringBuilder result, String thisFullNumber, String otherFullNumber, int carryIn, int carryOut, int index, int paddedIndex, boolean isAddition){

<span class="fc" id="L775">		int thisDigit = (thisFullNumber.charAt(index) - '0') - carryOut;</span>
<span class="fc" id="L776">		int otherDigit = otherFullNumber.charAt(index) - '0';</span>

<span class="fc bfc" id="L778" title="All 8 branches covered.">		if (index&lt;=paddedIndex &amp;&amp; (isAddition ? carryIn==0 : carryOut==0)){</span>

<span class="fc" id="L780">			result.insert(0, thisFullNumber.substring(0, index+1));</span>

<span class="fc" id="L782">			return result;</span>

		}

<span class="fc" id="L786">		int sum = 0;</span>

<span class="fc bfc" id="L788" title="All 2 branches covered.">		if (isAddition){</span>

<span class="fc" id="L790">			sum = thisDigit + otherDigit + carryIn;</span>
<span class="fc" id="L791">			carryIn = sum/10;</span>
<span class="fc" id="L792">			result.insert(0, sum%10);</span>

		}else{

<span class="fc" id="L796">			carryOut = 0;</span>
<span class="fc" id="L797">			carryIn = 0;</span>

<span class="fc bfc" id="L799" title="All 2 branches covered.">			if ((thisDigit)&lt;otherDigit){</span>

<span class="fc" id="L801">				carryIn = 10;</span>
<span class="fc" id="L802">				carryOut = 1;</span>

			}

<span class="fc" id="L806">			sum = thisDigit - otherDigit + carryIn;</span>
<span class="fc" id="L807">			result.insert(0, sum);</span>

		}


<span class="fc bfc" id="L812" title="All 2 branches covered.">		if (index==0){</span>

<span class="fc bfc" id="L814" title="All 2 branches covered.">			if (carryIn&gt;0){</span>

<span class="fc" id="L816">				result.insert(0, carryIn);</span>

			}

<span class="fc" id="L820">			return result;</span>

		}else{

<span class="fc" id="L824">			index--;</span>

<span class="fc" id="L826">			return this.addTwoTogether(result, thisFullNumber, otherFullNumber, carryIn, carryOut, index, paddedIndex, isAddition);</span>

		}

	}

	private String[] multiplication(String[] integerRows, StringBuilder zero, String thisInteger, String otherInteger, int index){

<span class="fc" id="L834">		StringBuilder result = this.multiplication(new StringBuilder(), thisInteger, otherInteger.charAt(index) - '0', 0, thisInteger.length() - 1);</span>

<span class="fc" id="L836">		result.append(zero);</span>
<span class="fc" id="L837">		zero.append(&quot;0&quot;);</span>

<span class="fc" id="L839">		integerRows[index] = result.toString();</span>

<span class="fc bfc" id="L841" title="All 2 branches covered.">		if (index==0){</span>

<span class="fc" id="L843">			return integerRows;</span>

		}else{

<span class="fc" id="L847">			index--;</span>

<span class="fc" id="L849">			return this.multiplication(integerRows, zero, thisInteger, otherInteger, index);</span>

		}

	}

	private StringBuilder multiplication(StringBuilder result, String thisInteger, int otherDigit, int carryIn, int index){

<span class="fc" id="L857">		int thisDigit = thisInteger.charAt(index) - '0';</span>

<span class="fc" id="L859">		int multi = (thisDigit * otherDigit) + carryIn;</span>
<span class="fc" id="L860">		carryIn = multi/10;</span>

<span class="fc" id="L862">		result.insert(0, multi%10);</span>

<span class="fc bfc" id="L864" title="All 2 branches covered.">		if (index==0){</span>

<span class="fc bfc" id="L866" title="All 2 branches covered.">			if (carryIn&gt;0){</span>

<span class="fc" id="L868">				result.insert(0, carryIn);</span>

			}

<span class="fc" id="L872">			return result;</span>

		}else{

<span class="fc" id="L876">			index--;</span>

<span class="fc" id="L878">			return this.multiplication(result, thisInteger, otherDigit, carryIn, index);</span>

		}

	}

	private ArrayList&lt;String&gt; powersOfTwo(int k){

<span class="fc" id="L886">		ArrayList&lt;String&gt; powers = new ArrayList&lt;&gt;();</span>

<span class="fc" id="L888">		powers.add(&quot;1&quot;);</span>

<span class="fc bfc" id="L890" title="All 2 branches covered.">		for(int i=1; i&lt;k; i++){</span>

<span class="fc" id="L892">			String factor = powers.get(i - 1);</span>

<span class="fc" id="L894">			powers.add(this.addTwoTogether(factor, factor, true));</span>

		}

<span class="fc" id="L898">		return powers;</span>

	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.11.202310140853</span></div></body></html>